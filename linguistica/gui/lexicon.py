# Definition of the class Lexicon for the Linguistica 5 GUI
# Jackson Lee, 2015

import json
from pathlib import Path

from ..lxa5lib import json_pload
from .lxa5libgui import (
    WORDLIST, WORD_NGRAMS, BIGRAMS, TRIGRAMS,
    SIGNATURES, SIGS_TO_STEMS, WORDS_TO_SIGS,
    TRIES, WORDS_AS_TRIES, SF_TRIES, PF_TRIES,
    PHONOLOGY, PHONES, BIPHONES, TRIPHONES,
    MANIFOLDS, WORD_NEIGHBORS, VISUALIZED_GRAPH, SHOW_MANIFOLD_HTML)

class Lexicon:
    def __init__(self, corpus_filename):

        self.corpus_filename = corpus_filename
        #----------------------------------------------------------------------#
        ###   data directly generated by other .py programs   ###

        # results from ngrams.py
        self.word_to_freq = None
        self.bigram_to_freq = None
        self.trigram_to_freq = None

        self.word_to_freq_path = None
        self.bigram_to_freq_path = None
        self.trigram_to_freq_path = None

        # results from lxa5.py
        self.sig_to_stems = None
        self.word_to_sigs = None

        self.sig_to_stems_path = None
        self.word_to_sigs_path = None

        # results from tries.py
        self.tries_LtoR = None
        self.tries_RtoL = None

        self.tries_LtoR_path = None
        self.tries_RtoL_path = None

        # results from phon.py
        self.phone_to_freq = None
        self.biphone_to_freq = None
        self.triphone_to_freq = None

        self.phone_to_freq_path = None
        self.biphone_to_freq_path = None
        self.triphone_to_freq_path = None

        # results from manifold.py
        self.word_to_neighbors = None
        self.word_to_neighbors_path = None

        self.retrieve_data_paths()

        #----------------------------------------------------------------------#

        self.n_types = None
        self.n_tokens = None


    def clear_data(self):

        # why do we need this function? at any given moment, we are just
        # looking at results for *one* (not many) of the following things
        # so we need only one thing loaded at any given point and should
        # clear everything else so as to save memory
        # will we change our mind on this point?
        # -- Jackson Lee, 2015/8/11

        # results from ngrams.py
        self.word_to_freq = None
        self.bigram_to_freq = None
        self.trigram_to_freq = None

        # results from lxa5.py
        self.sig_to_stems = None
        self.word_to_sigs = None

        # results from tries.py
        self.tries_LtoR = None
        self.tries_RtoL = None

        # results from phon.py
        self.phone_to_freq = None
        self.biphone_to_freq = None
        self.triphone_to_freq = None

        # results from manifold.py
        self.word_to_neighbors = None


    def retrieve_data_paths(self):
        corpus_dir = Path(self.corpus_filename).parent
        corpus_stem = Path(self.corpus_filename).stem

        # results from ngrams.py
        ngrams_path = Path(corpus_dir, "ngrams")
        self.word_to_freq_path = Path(ngrams_path, corpus_stem + "_words.json")
        self.bigram_to_freq_path = Path(ngrams_path, corpus_stem + "_bigrams.json")
        self.trigram_to_freq_path = Path(ngrams_path, corpus_stem + "_trigrams.json")

        # results from lxa5.py
        lxa_path = Path(corpus_dir, "lxa")
        self.sig_to_stems_path = Path(lxa_path, corpus_stem + "_SigToStems.json")
        self.word_to_sigs_path = Path(lxa_path, corpus_stem + "_WordToSigs.json")

        # results from tries.py
        tries_path = Path(corpus_dir, "tries")
        self.tries_LtoR_path = Path(tries_path, corpus_stem + "_trieLtoR.json")
        self.tries_RtoL_path = Path(tries_path, corpus_stem + "_trieRtoL.json")

        # results from phon.py
        phon_path = Path(corpus_dir, "phon")
        self.phone_to_freq_path = Path(phon_path, corpus_stem + "_phones.json")
        self.biphone_to_freq_path = Path(phon_path, corpus_stem + "_biphones.json")
        self.triphone_to_freq_path = Path(phon_path, corpus_stem + "_triphones.json")

        # results from manifold.py
        manifold_path = Path(corpus_dir, "neighbors")
        self.word_to_neighbors_path = Path(manifold_path,
                                         corpus_stem + "_1000_9_neighbors.json")


    def retrieve_data(self, item_str, cleardata=True):
        if cleardata:
            self.clear_data()

        # TODO: switch to native python json.load here and abandon the custom
        #   json_pload? json_pload is for serialized dicts created by
        #   json_pdump. Both json_pload and json_pdump work slower than 
        #   json.load and json.dump, because json_pload forces all keys and
        #   values to be strings, and json_pdump has to determine if it is 
        #   necessary to eval strings back to python objects -- this is what
        #   slows everything down. Also, another motivation for json_pdump
        #   was to "pretty dump" the dict so that it's human-readable when the
        #   json is opened as a text file. But now we have decided that the json
        #   files are only read by python and humans read the custom txt files,
        #   there seem no reasons to keep json_pdump and json_pload?
        #   -- Jackson Lee, 2015/8/25

        if item_str == WORDLIST:
            self.word_to_freq = json.load(self.word_to_freq_path.open())
        elif item_str == BIGRAMS:
            self.bigram_to_freq = json.load(self.bigram_to_freq_path.open())
        elif item_str == TRIGRAMS:
            self.trigram_to_freq = json.load(self.trigram_to_freq_path.open())

        elif item_str == SIGS_TO_STEMS:
            self.sig_to_stems = json_pload(self.sig_to_stems_path.open())
        elif item_str == WORDS_TO_SIGS:
            self.word_to_sigs = json_pload(self.word_to_sigs_path.open())

        elif item_str == WORDS_AS_TRIES:
            self.tries_LtoR = json.load(self.tries_LtoR_path.open())
            self.tries_RtoL = json.load(self.tries_RtoL_path.open())

        elif item_str == PHONES:
            self.phone_to_freq = json_pload(self.phone_to_freq_path.open())
        elif item_str == BIPHONES:
            self.biphone_to_freq = json_pload(self.biphone_to_freq_path.open())
        elif item_str == TRIPHONES:
            self.triphone_to_freq = json_pload(self.triphone_to_freq_path.open())

        elif item_str == WORD_NEIGHBORS:
            self.word_to_freq = json.load(self.word_to_freq_path.open())
            self.word_to_neighbors = json_pload(self.word_to_neighbors_path.open())

        elif item_str == VISUALIZED_GRAPH:
            return

